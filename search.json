[{"title":"Implementing Lock-Free Queues","date":"2022-07-01T01:51:37.000Z","url":"/2022/07/01/Implementing-Lock-Free-Queues/","tags":[["lock-free","/tags/lock-free/"]],"categories":[["undefined",""]],"content":"简介本篇论文介绍如何实现一个lock-free队列。 目的过往的lock-free队列存在各类缺陷，比如难以线性化，或者未考虑队列为空的情况。本篇论文引入dummy node，避免了队列为空时插入node的复杂情况，另外其它一些改进使得队列达到线性化。 算法基本算法Lock-free队列的c++版本代码如下所示。该算法中，队列的head指向的是第一个node的前一个node（如果队列为空时，head指向一个dummy node）。 ABA问题双字CAS可以解决ABA问题，但不能阻止ABA问题出现。文章作者提出了一种策略可以阻止ABA问题发生。 队列的ABA问题源自node可能在出队后又进队，算法难以分辨这类node是否被再次使用。论文提出的解决方法是给每个node添加一个引用计数，当计数为0时即可回收node。这个引用计数的方法和《lock free linked lists using compare-and-swap》中使用的相同。 数组实现在一个数组上实现队列是常见的方法，所以本篇论文也探讨了他们设计的队列在数组上的实现。但是他们的方法因为内存对齐原因，暂时只在理论上有效。 总结本论文提出了一种lock-free队列的实现方法。"},{"title":"A Non-Blocking Concurrent Queue Algorithm","date":"2022-06-30T13:23:47.000Z","url":"/2022/06/30/A-Non-Blocking-Concurrent-Queue-Algorithm/","tags":[["lock-free","/tags/lock-free/"]],"categories":[["undefined",""]],"content":"简介本文介绍了一种unrolled lock-free队列结构。 目的本文设计的队列中，每个node可以存放多个值，相当于过去队列中多个node合并成一个node，提高了cache性能并减少了内存开销。 总结本文是对过去lock-free队列的改进，主要利用cache-coherent遍历一个node多个elements。"},{"title":"A Pragmatic Implementation of Non-Blocking Linked-Lists","date":"2022-06-30T11:18:02.000Z","url":"/2022/06/30/A-Pragmatic-Implementation-of-Non-Blocking-Linked-Lists/","tags":[["lock-free","/tags/lock-free/"]],"categories":[["undefined",""]],"content":"简介本篇是lock-free链表的另一种实现形式，避免Valois版本过于复杂的缺点。 目的实现一个linearizable的lock-free链表。 算法数据结构 运算本篇论文假设链表的元素取值递增，然而为具有普遍性，我们在代码实现中默认链表取值顺序是随机的。 插入插入运算通过不断循环检查是否可以插入即可。 删除删除运算通过标记node来判断某个node是否被删除。删除操作分为两步，第一步标记node为删除状态，第二步直接删除该node。具体实现不再展示。 总结本篇论文给出了较简洁的lock-free链表结构，并论述其正确性。"},{"title":"lock free linked lists using compare-and-swap","date":"2022-06-29T12:27:06.000Z","url":"/2022/06/29/lock-free-linked-lists-using-compare-and-swap/","tags":[["lock-free","/tags/lock-free/"]],"categories":[["undefined",""]],"content":"简介本篇论文阐述了使用CAS实现无锁链表。在该论文发表之前，mutex互斥技术已经被广泛使用，spin locking的使用让mutex的效率进一步提升。然而mutex将会引入critical section，section内执行的代码很容易成为性能瓶颈或者造成优先级反转之类的问题。 Lock-free数据结构理论上效率更高，但当时lock-free数据结构的overhead过重，因此性能相比mutex反而更差。该论文第一次使用CAS实现了链表结构，并探讨了如何解决链表node回收等问题。 目的对于一个lock-free链表来说，插入一个node的过程非常直观：只需要新建一个node，将node插入指定位置即可。然而当删除一个node时，有一些情况会比较麻烦，例如node被删除时仍被其它线程访问，或者在被删除的node后插入新的node等。 Lock-free Linked List基础数据结构该论文设计的链表含有三种node，分别是： Normal node：存储实际数据的node。 Auxiliary node：用于辅助增删操作的node。 Dummy node：链表的第一个和最后一个node，不存储实际数据。 当链表尚未存数据时，链表内已经含有三个节点，第一个node和最后一个node为dummy node，中间还存有一个auxiliary node，如下图所示。 基本运算论文先介绍了几种lock-free程序中常用的几种函数。First函数返回链表的第一个dummy node，Last返回最后一个dummy node，Next返回Cursor指向的下一个node。 UpdateUpdate移除多余的auxiliary node，如下图所示。 InsertInsert直接在Cursor指向的node初插入即可。 DeleteDelete使用back link记录删除node的前一个node，并随后遍历并删除back link指向的node。 Memory Management本文还讨论了如何解决ABA问题，和管理空闲node。ABA问题采用计数方法解决，而空闲node回收则略微复杂一些。当分配一个node时，将从free list中申请，而当收回一个node时，则将该node放回free list中。 总结本篇论文属于lock-free领域经典论文之一，虽然它给出的实现和现在常见实现差别较大，但它增删链表node的思想仍有启发意义。"}]